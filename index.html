<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>粒子聚合文字动画</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: 'STXingkai', '华文行楷', cursive;
        }
        #final-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            color: #FFB6C1;
            font-size: 3rem;
            text-shadow: 0 0 20px #FF69B4, 0 0 40px #FF69B4;
            text-align: center;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            pointer-events: none;
            white-space: nowrap;
        }
        #final-text.show {
            opacity: 1;
        }
        .blessing {
            position: absolute;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            z-index: 20;
            animation: float-up 8s ease-out forwards; /* 进一步延长到8秒 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        @keyframes float-up {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            90% {
                opacity: 0.9; /* 在90%时仍然保持可见 */
            }
            100% {
                transform: translateY(-400px) scale(0.8); /* 飘得更高 */
                opacity: 0;
            }
        }
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            z-index: 15;
        }
        @keyframes firework-explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
</head>
<body>
    <div id="final-text">祝廖盈盈万事如意，心想事成！</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// 星云粒子系统
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 创建粒子系统
const particlesGeometry = new THREE.BufferGeometry();
const particleCount = 15000;
const posArray = new Float32Array(particleCount * 3);
const colorArray = new Float32Array(particleCount * 3);

// 存储粒子的初始位置和目标位置
const initialPositions = [];

// 初始化粒子位置
for(let i = 0; i < particleCount * 3; i += 3) {
    posArray[i] = (Math.random() - 0.5) * 20;
    posArray[i+1] = (Math.random() - 0.5) * 20;
    posArray[i+2] = (Math.random() - 0.5) * 8;
    
    initialPositions.push(
        posArray[i],
        posArray[i+1],
        posArray[i+2]
    );
    
    colorArray[i] = 0.8 + Math.random() * 0.2;
    colorArray[i+1] = 0.8 + Math.random() * 0.2;
    colorArray[i+2] = 0.8 + Math.random() * 0.2;
}

particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

const particlesMaterial = new THREE.PointsMaterial({
    size: 0.035,
    vertexColors: true,
    transparent: true,
    blending: THREE.AdditiveBlending,
    color: 0xFFB6C1
});

const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

camera.position.z = 8;

// 文字序列
const words = ["祝", "廖", "盈", "盈", "万", "事", "如", "意"];
let currentWordIndex = 0;
let targetPositions = [];
let isAnimating = false;
let animationProgress = 0;
let animationState = "aggregating";
let allWordsComplete = false;

// 创建文字形状的目标位置
function createTextPositions(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 2400;
    canvas.height = 1200;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 800px "STXingkai", "华文行楷", "ZCOOL XiaoWei", "SimHei", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    const textPixels = [];
    const step = 3;
    
    for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x += step) {
            const index = (y * canvas.width + x) * 4;
            if (data[index + 3] > 200) {
                textPixels.push({ x, y });
            }
        }
    }
    
    if (textPixels.length < particleCount / 2) {
        textPixels.length = 0;
        const fineStep = 2;
        for (let y = 0; y < canvas.height; y += fineStep) {
            for (let x = 0; x < canvas.width; x += fineStep) {
                const index = (y * canvas.width + x) * 4;
                if (data[index + 3] > 200) {
                    textPixels.push({ x, y });
                }
            }
        }
    }
    
    const selectedPixels = [];
    const pixelsCopy = [...textPixels];
    
    for (let i = 0; i < particleCount && pixelsCopy.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * pixelsCopy.length);
        selectedPixels.push(pixelsCopy[randomIndex]);
        pixelsCopy.splice(randomIndex, 1);
        
        if (pixelsCopy.length === 0 && i < particleCount - 1) {
            pixelsCopy.push(...textPixels);
        }
    }
    
    const positions = [];
    for (let i = 0; i < selectedPixels.length; i++) {
        const pixel = selectedPixels[i];
        const scale = 0.0055;
        const posX = (pixel.x - canvas.width/2) * scale;
        const posY = -(pixel.y - canvas.height/2) * scale;
        const posZ = (Math.random() - 0.5) * 0.3;
        
        positions.push(posX, posY, posZ);
    }
    
    return positions;
}

// 启动文字聚合动画
function startTextAnimation() {
    isAnimating = true;
    animationState = "aggregating";
    animationProgress = 0;
    
    targetPositions = createTextPositions(words[currentWordIndex]);
}

// 动画函数 - 只使用龙卷风特效
function animateParticles() {
    if (!isAnimating || allWordsComplete) return;
    
    if (animationState === "aggregating") {
        animationProgress += 0.012; // 更慢的聚合速度
        
        if (animationProgress >= 1) {
            animationProgress = 1;
            animationState = "holding";
            
            setTimeout(() => {
                animationState = "dispersing";
            }, 1800);
        }
    } else if (animationState === "dispersing") {
        animationProgress -= 0.015; // 更慢的消散速度
        
        if (animationProgress <= 0) {
            animationProgress = 0;
            isAnimating = false;
            
            currentWordIndex++;
            
            if (currentWordIndex >= words.length) {
                allWordsComplete = true;
                setTimeout(() => {
                    document.getElementById('final-text').classList.add('show');
                    startFireworks();
                    startBlessings();
                }, 500);
            } else {
                setTimeout(startTextAnimation, 600);
            }
        }
    }
    
    const positions = particlesGeometry.attributes.position.array;
    
    for (let i = 0; i < positions.length; i += 3) {
        const easedProgress = easeInOutQuart(animationProgress);
        
        const targetX = targetPositions[i];
        const targetY = targetPositions[i+1];
        const targetZ = targetPositions[i+2];
        
        const startX = initialPositions[i];
        const startY = initialPositions[i+1];
        const startZ = initialPositions[i+2];
        
        const dx = targetX - startX;
        const dy = targetY - startY;
        const dz = targetZ - startZ;
        
        // 龙卷风特效
        const spiralAngle = (1 - easedProgress) * Math.PI * 4 + i * 0.1;
        const spiralRadius = Math.sqrt(dx*dx + dy*dy) * (1 - easedProgress) * 0.6;
        const finalX = startX + dx * easedProgress + Math.cos(spiralAngle) * spiralRadius;
        const finalY = startY + dy * easedProgress + Math.sin(spiralAngle) * spiralRadius + (1 - easedProgress) * -8;
        const finalZ = startZ + dz * easedProgress;
        
        positions[i] = finalX;
        positions[i+1] = finalY;
        positions[i+2] = finalZ;
    }
    
    particlesGeometry.attributes.position.needsUpdate = true;
}

// 缓动函数
function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
}

// 烟花效果
function createFirework(x, y) {
    const colors = ['#FF1461', '#18FF92', '#5A87FF', '#FBF38C', '#FF69B4', '#00CED1'];
    const color = colors[Math.floor(Math.random() * colors.length)];
    const particleCount = 30;
    
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'firework';
        particle.style.background = color;
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        particle.style.boxShadow = `0 0 10px ${color}`;
        
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 100 + Math.random() * 100;
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        
        particle.style.animation = 'firework-explode 1s ease-out forwards';
        particle.style.transform = `translate(${tx}px, ${ty}px) scale(${Math.random() + 0.5})`;
        
        document.body.appendChild(particle);
        
        setTimeout(() => particle.remove(), 1000);
    }
}

function startFireworks() {
    setInterval(() => {
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight * 0.7;
        createFirework(x, y);
    }, 800);
}

// 祝福弹幕 - 增加更多祝福语
const blessings = [
    '祝你万事如意', '心想事成', '笑口常开', '身体健康', '工作顺利',
    '学业进步', '前程似锦', '财源广进', '幸福美满', '吉祥如意',
    '平安喜乐', '事事顺心', '天天开心', '梦想成真', '好运连连',
    '福星高照', '一帆风顺', '大展宏图', '步步高升', '生活美好',
    '永远快乐', '健康长寿', '合家欢乐', '喜气洋洋', '锦绣前程',
    '青春永驻', '才华横溢', '事业有成', '爱情甜蜜', '家庭和睦',
    '岁月静好', '前程万里', '意气风发', '马到成功', '金榜题名',
    '花开富贵', '福寿安康', '年年有余', '四季平安', '五福临门'
];

const blessingColors = [
    '#FFE4E1', '#FFB6C1', '#FFA07A', '#98FB98', '#87CEEB',
    '#DDA0DD', '#F0E68C', '#E0FFFF', '#FFE4B5', '#FFC0CB'
];

function createBlessing() {
    const blessing = document.createElement('div');
    blessing.className = 'blessing';
    blessing.textContent = blessings[Math.floor(Math.random() * blessings.length)];
    blessing.style.background = blessingColors[Math.floor(Math.random() * blessingColors.length)];
    blessing.style.left = (Math.random() * (window.innerWidth - 200)) + 'px';
    blessing.style.bottom = '0px';
    
    document.body.appendChild(blessing);
    
    setTimeout(() => blessing.remove(), 8000); // 与CSS动画时间匹配
}

function startBlessings() {
    setInterval(createBlessing, 150); // 进一步加快出现频率
}

// 主动画循环
function animate() {
    requestAnimationFrame(animate);
    
    animateParticles();
    
    if (allWordsComplete || (!isAnimating && animationProgress === 0)) {
        const positions = particlesGeometry.attributes.position.array;
        for(let i = 0; i < positions.length; i += 3) {
            positions[i] += Math.sin(Date.now() * 0.0003 + i) * 0.002;
            positions[i+1] += Math.cos(Date.now() * 0.0004 + i) * 0.002;
        }
        particlesGeometry.attributes.position.needsUpdate = true;
    }
    
    if (!allWordsComplete) {
        particlesMesh.rotation.z = Math.sin(Date.now() * 0.0001) * 0.02;
    }
    
    renderer.render(scene, camera);
}
animate();

setTimeout(startTextAnimation, 2000);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

const bgGradient = document.createElement('div');
bgGradient.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at 50% 50%, #FF149330, #000000);
    pointer-events: none;
    z-index: -1;
`;
document.body.appendChild(bgGradient);
</script>
</body>
</html>